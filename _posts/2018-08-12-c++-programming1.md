---
layout: post
categories:
  - Computer Science
tags:
  - Computer Science
  - C++ programming
---
## 1강 객체지향 언어의 개념


1) 추상화와 객체지향 프로그래밍

* 추상화란? 복잡도를 낮추는 기술. 우리 주변은 매우 복잡함 - > 핵심적인 요소들로만 구성되는 것.

예 ) 자동차 :차종, 생산연도, 오디오,에어백, 최고속력, 선루프....... 

     자동차 게임으로 만든다면? => 최고속력, 가속/감속, 핸들조작, 코너링 성능...
	 
     중고차 매매 앱 => 차종, 생산년도, 시트, 선루프, 주행거리...
	 
* 객체란?

속성(Attribute) 행위(Method)

데이터1 + 행위1

데이터2 + 행위2

...


* 캡슐화(encapsulation)란?

예) TV : 구동하는 회로는 내부에 감춤. However, 사용자는 외부에 조작 단추를 이용하여 TV를 시청함.

아날로그 TV => 디지털 TV 로 바뀜. 내부 회로는 바뀔지언정 외부조작 단추가 동일하면 사용방법은 변하지 않음.

객체 내부와 외부 사용자의 관점을 분리시킴. => 캡슐화

객체외부 --|공개함수|--> 객체 내부

         (직접사용불허)
	 
캡슐화의 장점 : 소프트웨어의 유지보수가 용이함. 재사용의 용이함.(개발비용을 줄일 수 있음)

객체를 이용한 모델링의 예 ) 

계수기(counter) 객체

reset count 

value

getValue


2) 객체지향 프로그래밍 언어의 주요 개념


* 객체와 상호작용하기 위한 방법

-메시지 전달 

객체가 다른 객체에게 원하는 작업을 실행하도록 요구. 메서드를 통하여 구현.

-클래스(class)

객체의 설계도. 객체가 포함할 속성에 대한 명세와 메서드의 정의를 포함함.

예) counter => value:int, reset():void, count():void, getValue():int

클래스를 통한 사례생성

Counter1:Counter => value = 3

Counter2:Counter => value = 5

...

=>사례(instance)


* 상속(inheritance)

공통적인 것들을 모아 상위 클래스를 만들고,

개별클래스는 이를 제외한 고유한 속성 및 메소드만 포함해서 하위 클래스를 만듦.

=> 하위 클래스들은 상위 클래스의 공통 특성들을 물려받게 함.



* 다형성(polymorphism)

동일한 메소드가 대상에 따라 그것에 맞는 다른 방법으로 동작하는 것.

예) draw : 그리는것는 같지만 원을 그리는 방법과 다각형을 그리는 방법은 다름.

*동적 바인딩(dynamic binding)

바인딩이 프로그램의 실행 과정에서 일어나도록 하는 것.

  fig -> draw(); // fig : Figure 포인터

  fig가 무엇을 가리키고 있느냐에 따라 다르게 그림. 다각형이냐, 원이냐...


  3) C++ 언어

  1979년 Bell 연구소의 Bjarne Stroustrup이 C언어를 확장하여 만든 프로그래밍 언어.

  C with Classes (최초의 이름) : class를 가진 C언어다.

  => 1983년부터 C++라는 이름을 사용함.(확장된 C라는 의미로?)

  => 1989년에 국제표준화기구(ISO)에서 표준화작업 착수함.
  
  => 1998년에 C++98 나옴.

  => 2003년에 C++03버전 나옴.

  => 2007년에 C++ TR1 나옴.

  => 2011년에 C++11나옴.

  => 2014년에 C++14나옴.


  마이크로소프트의 컴파일러가 모든 버전을 커버하지 못 할 수 있음.

  C언어에 클래스, 상속, 다형성, 동적 바인딩, 템플린, 예외처리 등을 추가하여 확장된 언어.

  !C언어를 알고있다는 전제하에 C++ 강의를 진행하겠음!


## 2강 C++ 언어의 기초(1)

* C++ 소스 프로그램 파일 


* C++ 헤더 파일: 클래스, 함수의 원형, 매크로, 전역변수, 상수 등 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일.

               단독으로 컴파일 되지 않고, #include 라는 선행처리기 지시어에 의해 소스 프로그램 파일에 삽입되어 함께 컴파일됨.

			   확장자는 일반적으로 '.h'를 사용함.

			   
* 선행처리란 ? 

  C++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 것.

  선행처리기 지시어(preprocessor directives)로 처리를 지시함.

  선행처리기 지시어는 '#'로 시작함.

  선행처리기 지시어 문장은 한 행에 한 개의 문장을 작성함.

  ex) 헤더파일 삽입, 조건부 컴파일, 매크로 확장 등.
  
{% highlight js %}

//첫번째 프로그램 a.cpp
// 선행 처리기 지시어. 번역전에 a.h파일을 이 자리에 삽입하라.(내가 만든 파일은 ""로 묶고 C++안에 있는 라이브러리는<>로 묶음.
#include <iostream>"a.h" 
#define DEBUG_MODE //디버그 모드가 정의되어 있는 상태

using namespace std;  //명칭 공간 => 동일한 명칭이라도 서로 다른 명칭공간에서 정의되었다면 별개의 것으로 구분함. 중복되면 안되므로...
		      // 여러 프로그래머가 작성한 프로그램을 결합하여 완성된 프로그램을 만들 경우 각자 필요한 명칭을 독립적으로 만들어 사용가능.
		      // 전역 명칭공간: 특정 명칭공간에 속하지 않는 기본 명칭공간. 앞에 아무것도 안 쓰면 기본임.
		      // std 명칭공간 : 표준 C++ 라이브러리의 명칭들이 정의되어 있는 명칭공간.
		      // 'using namespac' 구문 : 특정 명칭공간을 기본 명칭공간에 포함시키기 위한 구문.
int main()
{
	cout << "나의 첫번째 C++프로그램">>
	return 0;
}

int f(int x) {
	#ifdef DEBUG_MODE //디버그 모드가 정의되어 있느냐?
	 	cout << x << endl;
	#endif
		return x*x;

}

{% endhighlight %}


{% highlight js %}

#include <iostream>
//using namespace std; // 이걸 선언 안해주면 아래와 같이 std 안에 있는 함수 쓸때마다 std::라고 써줘야 함.

namespace myNSp1 { int n = 10; }
namespace myNSp2 { int n = 20; } 
int n = 30;   			 // 전역

int main()
{
	int n = 40;
	std::cout << myNSp1::n << std::endl; //endl : 줄바꿈 (C에서 \n과 같은 역할), cout : 데이터를 문자열로 변환하여 출력, << : 출력 연산자
	std::cout << myNSp2::n << std::endl;
	std::cout << ::n << std::endl;
	std::cout << n << std::endl;
	return 0;
	//출력결과
	/*
		10
		20
		30
		40
	*/
}

{% endhighlight %}


* cin 객체

표쥰 입력 스트림 객체.

입력 연산자 : >>

ex ) int a;

     char str[100];
     
     cin >> a >> str;
     
     
{% highlight js %}

#include <iostream>
//using namespace std; // 이걸 선언 안해주면 아래와 같이 std 안에 있는 함수 쓸때마다 std::라고 써줘야 함.

namespace myNSp1 { int n = 10; }
namespace myNSp2 { int n = 20; } 
int n = 30;   			 // 전역

int main()
{
	int n = 40;
	std::cout << myNSp1::n << std::endl; //endl : 줄바꿈 (C에서 \n과 같은 역할), cout : 데이터를 문자열로 변환하여 출력, << : 출력 연산자
	std::cout << myNSp2::n << std::endl;
	std::cout << ::n << std::endl;
	std::cout << n << std::endl;
	return 0;
	//출력결과
	/*
		10
		20
		30
		40
	*/
}

{% endhighlight %}

* 기본 자료형

1) 정수를 표현하는 자료형

 고정소수점 방식의 숫자 표현. ( 소수점 위치가 변하지 않음.)

char(1byte), short(2byte), int, long(4byte) --> 컴퓨터의 성능에 따라 달라질 수 있음.

signed 또는 unsigned

overflow를 주의해야 함.

bool : true 또는 false (1byte)


2) 실수를 표현하는 자료형

부동 소수점 방식의 숫자 표현.( 소수점 위치가 변할 수 있음.)

float(4byte)

부호 1비트, 지수부 8비트, 가수부 23비트로 구성.


Q. 1200을 float형으로 나타내면? 

1200.0f

12e2f


double(8byte)

부호 1비트, 지수부 11비트, 가수부 52비트로 구성.

Q. 1200을 double형으로 나타내면?

1200.

1200.0

12e2

1.2e+3


* 변수와 상수

변수 : 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역.

변수에는 이름이 지정되어야 함.

모든 변수는 사용하기 전에 미리 선언해야 함.

함수내부 : 지역변수

함수외부 : 전역변수

상수 선언 형식 : const int c = 10; // 초기화를 통해서만 값을 정할 수 있음. 정해진 값은 변경할 수 없음.


CircleArea.cpp

{% highlight js %}

#include <iostream> //cin, cout을 사용하려고
using namespace std; //cin,cout을 사용할 때마다 std를 선언해줘야 하는 번거러움을 덜려고

int main()
{
	const double PI = 3.14159;

	double radius;
	
	cout << "원의 반경을 입력하시오 : ";  // << : 출력연산자
	cin >> radius; // >> : 입력연산자
	double area = radius * radius * PI;
	cout << "원의 면적 = " << area << endl;

	return 0;
}

{% endhighlight %}


* 자료형의 변환

자동적 형 변환 ( 묵시적 형변환 ) : 우선순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 같은 형으로 자동적으로 변환됨.

int a = 10;

double b = 15.5; 

a + b(double형이 우선순위가 더 높으므로 a가 double형으로 변환된 후 계산됨.)

intVar = doubleVar + intVar * floatVar;

1) intVar * floatVar  --> float형이 우선순위가 더 높으므로 intVar이 float형으로 변환된 후에 계산됨.

2) doubleVar + 1) --> double형이 1번에서 나온 결과인 float형보다 우선순위가 높으므로 1번에서 나온 결과가 double로 형변환 된 후에 계산됨.

3) intVar = 2) --> 2)의 double형값을 int 로 바꾸어 대입함. 소수점 아래는 다 버리기 때문에 오차 발생 가능.


형변환 연산자

1) dynamic_cast : 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시함.

2) static_cast : 실행 중에 형 검사를 하지 않으며, 컴파일 할 때 수식에 지정된 그대로 변환함.

	 ex) static_cast<int> (n / 10.0)
	     
	     형변환 연산자 <변환하고자 하는 목표 자료형> (형변환 대상 수식)

3) reinterpret_cast : 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환함.(꼭 필요할 때만 주의해서 사용할 것)

4) const_cast : const 지정을 일시 해제함.(값을 일시적으로 변경가능하도록 함)



* 연산자

논리 합 |, 논리 곱 &, 배타적 논리 함 ^, 부정 ~

비트 이동 연산자 << : 좌측 이동, >> : 우측이동.

x는 unsigned char 0X96 (1001 0110)

y는 signed char 0X96 (1001 0110)

우측이동의 경우 signed형 데이터에 대해서는 부호를 유지할 수 있도록 부호와 같은 비트가 채워짐.

x << 2 : x를 2만큼 왼쪽으로 이동시켜라.

y >> 2 : y를 2만큼 우측으로 이동시켜라.

unsigned : 부호 없이 양수만 취급함.

signed  : 부호구분함. 맨 앞의 비트는 부호를 의미함. 0일경우에 음수, 1일 경우에 양수.


## 3강 C++ 언어의 기초(2)

## 1강 자료구조란 무엇인가?

자료(data) : 현실 세계에서 관찰이나 측정을 통해서 수집된 값이나 사실. ex) 점수, 이름, 학번...

정보 : 처리과정을 거져서 정리되고 정돈된 '자료'의 2차 처리 결과물. 


I = P (D,A)

정보 = 처리(자료, 알고리즘)

추상화 : 공통의 특징을 뽑아 내는 것.

자료의 추상화 : 다양한 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 자료의 구조에 대해서 공통의 특징만을 뽑아 정의한 것.

자료의 추상화에는 컴퓨터 내부의 이진수의 표현 방법, 저장 위치 등은 포함되지 않고 단순하게 개발자의 머릿속에 그림을 그리는 것처럼 개념화 하는 것.


* 자료구조의 개념

추상화를 통해 자료의 논리적 관계를 구조화한 것.

자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율적으로 수행되거나 소프트웨어의 확장성에 문제가 생길 수 있음.

자료구조는 입력값의 추상화된 상태라면, 알고리즘은 컴퓨터가 수행해야 할 명령의 추상화.


개발자         ->    추상화   ->       자료구조     <-       구체화            <-       컴퓨터

(사람에 가까움)   (c,java등 언어)                         (컴파일러)         (010110 물리적 값에 가까움. 구체화)


입력될 값을 머릿속에서 추상화된 형태(자료구조)로 구조화하고,

수행되어야 할 명령어를 머릿속에서 추상화된 형태(알고리즘)로 체계화

자료구조 -> 입력값 -> 컴퓨터 -> 출력

                       ^
		       
		       |
		       
		    프로그램
                       
		       ^
		       
		       |
		    
		    알고리즘


* 자료구조와 알고리즘의 관계

알고리즘 : 컴퓨터에게 일을 시키는 명령들의 덩어리.

	   컴퓨터에 의해 수행되기 위해 필요한 명령어들의 유한 집합이 사람의 머릿속에 추상화되어 존재하는 것.
	   
	   사람(개발자)이 컴퓨터에게 일을 시키기 위해서는 사람(개발자)의 의도와 명령을 전달해 줄 수 있는 방법(언어/글) => 프로그래밍 언어
	   
알고리즘의 조건 : 출력, 유효성(valid: 어떤 언어로 프로그래밍되든 언제나 효과가 같아야 한다.), 

		 입력, 명확성, 유한성(끝나는 조건이 명확해야 한다. 단,운영체제는 무한루프 프로그램임.)


* 알고리즘 성능의 분석과 측정

실행시간 분석 : 알고리즘을 실행하는데 필요한 실행시간을 추정(계산)하여 알고리즘의 성능을 분석(performance analysis). 

               A가 좋을까 B알고리즘이 좋을까 결정하는 데 쓰임.

실행시간의 예측 : 알고리즘의 실행 횟수를 O(n)이라고 표현. 같은 O(n)을 가진다고 해서 같은 실행 시간을 갖는 것이 아니라 

	         실행 시간의 유사한 증가 경향.
		 
		 
실행메모리 분석 : 알고리즘을 실행하는데 필요한 공간(메모리)을 추정하여 알고리즘의 성능을 분석(performance analysis)

실행메모리의 예측

: 고정 공간은 프로그램의 크기나 입출력의 횟수에 관계없이 컴파일 시에 결정되어 프로그램의 실행이 끝날 때까지 고정적으로 필요한 메모리 공간.

  가변 공간은 프로그램의 실행 과정에서 동적으로 할당되어야 하는 자료 구조와 변수들을 위해 필요한 메인메모리 공간.
  
  Sp = Sc + Se (공간복잡도 = 고정공간 + 가변공간)
  
  
 성능측정 : 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간을 측정하여 알고리즘의 성능을 측정(performance measurement). 비용이 듬.
 
 실행 시간의 측정 : 실제로 실행 시간을 시계로 잰다는 것, 실제로 실행될 수 있는 프로그램(실행파일)이 있어야 함, 시스템 시계(system clock)을 이용.
 
 
 ## 2강. 배열
 
 
 
 
 


